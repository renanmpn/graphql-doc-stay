# -------------------------------------
# Scalar definitions
# -------------------------------------
scalar DateTime   # ISO 8601 full timestamp (e.g., 2024-10-20T15:30:00Z)
scalar Date       # Calendar date (YYYY-MM-DD)
scalar JSON       # Arbitrary structured data (object, array, etc.)
scalar Decimal    # High-precision decimal number

"""
Pagination information for forward-only navigation.
"""
type PageInfo {
  """True if there are more items after this page."""
  hasNextPage: Boolean!
  """Cursor to continue pagination."""
  endCursor: String
}

########################
# Filters & Queries
########################

enum SortDirection { ASC DESC }

"""
Filter set for listing subscriptions. Supports multi-tenant scoping and forward-only pagination.
Notes:
- Results are always ordered by a stable cursor defined by the server.
- If both merchant auth and merchantId are provided, merchant auth takes precedence.
- `email` is a convenience filter (server may normalize case/whitespace).
"""
input SubscriptionFilter {
  ids: [ID!]
  merchantId: ID
  customerIds: [ID!]
  variantIds: [ID!]
  statuses: [SubscriptionStatus!]
  minNextBillingDate: DateTime
  maxNextBillingDate: DateTime
  externalIds: [String!]
  email: String
}

"""
Available filters when querying customers.
"""
input CustomerFilter {
  id: ID
  merchantId: ID
  externalId: ID
  emailContains: String
  phoneContains: String
}

"""
Filters for listing orders generated by subscriptions. Use with forward-only pagination.
"""
input OrdersFilter {
  merchantId: ID
  subscriptionId: ID
  customerId: ID
  subscriberEmail: String
  minCreatedAt: DateTime
  maxCreatedAt: DateTime
  externalOrderId: String
}

"""
Filters for listing billing attempts. Useful to detect in-flight attempts or diagnose failures.
"""
input BillingAttemptsFilter {
  merchantId: ID
  subscriptionId: ID
  customerId: ID
  hasError: Boolean
  source: BillingAttemptSource
  minCreatedAt: DateTime
  maxCreatedAt: DateTime
}

"""
Filter that MUST uniquely identify a single customer.
Exactly one field must be provided. If more than one is provided, server returns
a validation error. If multiple customers match, server returns code=MULTIPLE_MATCHES.
"""
input UniqueCustomerFilter {
  id: ID
  externalId: ID
  email: String
}

"""
Filter that MUST uniquely identify a single subscription.
Exactly one field must be provided. If more than one is provided, server returns
a validation error. If multiple subscriptions match, server returns code=MULTIPLE_MATCHES.
"""
input UniqueSubscriptionFilter {
  id: ID
  externalId: ID
}

###############################
# Edges & Connections
###############################

"""
Connection wrapper for a paginated list of Customers.
Includes partial errors instead of throwing.
"""
type CustomerConnection {
  edges: [CustomerEdge!]!
  pageInfo: PageInfo!
}

type CustomerEdge {
  """Opaque cursor representing the position of this customer."""
  cursor: String!
  """The actual customer record."""
  node: Customer!
}
"""
Paginated list of subscriptions with cursor-based pagination.
Includes partial errors without failing the entire query.
"""
type SubscriptionConnection {
  """
  List of subscription edges containing the subscription node
  and its associated pagination cursor.
  """
  edges: [SubscriptionEdge!]!

  """Pagination metadata for forward-only navigation."""
  pageInfo: PageInfo!
}

"""
Represents one edge in the subscription connection.
Contains the actual subscription and its pagination cursor.
"""
type SubscriptionEdge {
  """Opaque cursor representing the position of this subscription in the list."""
  cursor: String!

  """The actual subscription record."""
  node: Subscription!
}

# ------------------------------------------------------------

"""
Paginated list of products with cursor-based pagination.
Includes partial errors without failing the entire query.
"""
type ProductConnection {
  """
  List of product edges containing the product node
  and its associated pagination cursor.
  """
  edges: [ProductEdge!]!

  """Pagination metadata for forward-only navigation."""
  pageInfo: PageInfo!
}

"""
Represents one edge in the product connection.
Contains the actual product and its pagination cursor.
"""
type ProductEdge {
  """Opaque cursor representing the position of this product in the list."""
  cursor: String!

  """The actual product record."""
  node: Product!
}

"""
Paginated list of variants with cursor-based pagination.
Includes partial errors without failing the entire query.
"""
type VariantConnection {
  edges: [VariantEdge!]!
  pageInfo: PageInfo!
}

type VariantEdge {
  """Opaque cursor representing the position of this variant in the list."""
  cursor: String!
  """The actual variant record."""
  node: ProductVariant!
}

# ------------------------------------------------------------

"""
Paginated list of payment methods with cursor-based pagination.
Includes partial errors without failing the entire query.
"""
type PaymentMethodConnection {
  """
  List of payment method edges containing the payment method node
  and its associated pagination cursor.
  """
  edges: [PaymentMethodEdge!]!

  """Pagination metadata for forward-only navigation."""
  pageInfo: PageInfo!
}

"""
Represents one edge in the payment method connection.
Contains the actual payment method and its pagination cursor.
"""
type PaymentMethodEdge {
  """Opaque cursor representing the position of this payment method in the list."""
  cursor: String!

  """The actual payment method record."""
  node: PaymentMethod!
}


########################
# Queries
########################

"""The root query type."""
type Query {
  # ---- Customers ----
  customer(id: ID!): Customer

  """
  Returns a single customer matched by a unique filter.
  Exactly one of (id | externalId | email) must be provided.
  If the filter matches multiple records, the server MUST return a domain error
  (e.g., code=MULTIPLE_MATCHES) rather than picking arbitrarily.
  """
  customerBy(filter: UniqueCustomerFilter!): Customer

  """
  List customers using optional filters and forward-only pagination.
  Partial failures are returned in the connection `errors` field.
  """
  customers(filter: CustomerFilter, first: Int = 20, after: String): CustomerConnection!

  # ---- Subscriptions ----
  """
  List subscriptions using filters such as merchant/customer, statuses, variantIds, nextBillingDate range,
  externalIds and email. Supports forward-only pagination via `pageInfo { hasNextPage, endCursor }`.
  Partial failures are surfaced in `SubscriptionConnection.errors` without failing the entire query.
  Authorization:
  - Merchant context: returns subscriptions of the merchant tenant.
  - Customer context: restricted to the authenticated customer (JWT), regardless of filters.
  """
  subscriptions(filter: SubscriptionFilter, first: Int = 20, after: String): SubscriptionConnection!

  """
  Return a single subscription matched by a unique filter. Exactly one field must be provided.
  If multiple subscriptions match, the server returns a domain error with code=MULTIPLE_MATCHES.
  """
  subscriptionBy(filter: UniqueSubscriptionFilter!): Subscription

  """
  Aggregate metrics (e.g., count) over subscriptions that match the filter. Does not page.
  """
  subscriptionsAggregate(filter: SubscriptionFilter): SubscriptionsAggregate!

  subscription(id: ID!): Subscription

  # ---- Orders ----
  """
  List subscription orders using filters such as subscriptionId, customerId/email and date ranges.
  For MVP this returns a simple list; if pagination is needed later, migrate to an OrderConnection.
  """
  orders(filter: OrdersFilter, first: Int = 20, after: String): [Order!]!

  # ---- Billing Attempts ----
  """
  List billing attempts with optional filters (merchant, subscription, hasError, time window).
  For MVP this returns a simple list; migrate to a Connection if pagination becomes necessary.
  """
  billingAttempts(filter: BillingAttemptsFilter, first: Int = 20, after: String): [BillingAttempt!]!

  # ---- Payment methods ----
  """
  List payment methods of a customer with forward-only pagination.
  Masked PCI-safe fields only. Merchant-scoped by auth; customers can only see their own.
  """
  paymentMethods(customerId: ID!, first: Int = 20, after: String): PaymentMethodConnection!

  """
  List the next N draft orders for a given subscription.
  Server clamps nextN (recommended max: 5).
  """
  draftOrders(subscriptionId: ID!, nextN: Int = 5): [DraftOrder!]!
}

# ---------- Shared inputs ----------

input AddressInput {
  name: String
  firstName: String
  lastName: String
  line1: String
  line2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  phone: String
}

input FrequencyInput {
  value: Int!
  unit: FrequencyUnit!
}

input BillingAnchorInput {
  day: Int!
  month: Int!
  year: Int
  type: BillingAnchorType!
}

input LineDeliveryCadenceInput {
  everyXOrders: Int!
  remainingCycles: Int
  isActive: Boolean
}

input CreateSubscriptionLineInput {
  variantId: ID!
  quantity: Int! = 1
  isOneTime: Boolean = false
  """
  Optional price override in the subscription currency.
  Server will normalize to currency precision (e.g., 2 decimals) on read/write.
  """
  priceOverride: Float
  deliveryCadence: LineDeliveryCadenceInput
  customAttributes: JSON
  bundleId: ID
}

input UpdateSubscriptionLineInput {
  lineId: ID!
  quantity: Int
  """
  Optional price override in the subscription currency.
  Server will normalize to currency precision (e.g., 2 decimals) on read/write.
  """
  priceOverride: Float
  swapVariantId: ID
  deliveryCadence: LineDeliveryCadenceInput
  customAttributes: JSON
}

input GiftInput {
  gifteeName: String
  gifteeEmail: String
  message: String
  deliveries: Int
}

input CreateSubscriptionInput {
  merchantId: ID!
  customerId: ID!
  frequency: FrequencyInput!
  anchors: [BillingAnchorInput!]
  address: AddressInput
  lines: [CreateSubscriptionLineInput!]!
  paymentMethodId: ID
  discountCodes: [String!]
  customAttributes: JSON
  gift: GiftInput
}

input UpdateSubscriptionInput {
  id: ID!

  frequency: FrequencyInput
  anchors: [BillingAnchorInput!]

  customAttributes: JSON

  nextBillingDate: DateTime
  nextDeliveryDate: DateTime

  status: SubscriptionStatus
  cancellationReason: String

  address: AddressInput

  paymentMethodId: ID
  shippingMethod: String
}

input UpdateCustomerInput {
  id: ID!
  firstName: String
  lastName: String
  phone: String
}

"""
Edit operations to apply to a DraftOrder.
- ADD: add a new ad-hoc line (one-time) by variantId.
- UPDATE: change fields of an existing draft line (by draft line id).
- REMOVE: remove a line from this draft only (does not delete the subscription line).
"""
input DraftOrderLineEdit {
  action: DraftOrderEditAction!
  """Required for UPDATE/REMOVE; ignored for ADD."""
  draftLineId: ID
  """Required for ADD; ignored for UPDATE/REMOVE."""
  variantId: ID
  """Optional; applies to ADD or UPDATE."""
  quantity: Int
  """Optional unit price override; server normalizes to currency precision."""
  priceOverride: Float
}

enum DraftOrderEditAction { ADD UPDATE REMOVE SKIP }

input UpdateDraftOrderInput {
  draftOrderIndex: Int!
  edits: [DraftOrderLineEdit!]!
}

type DraftOrderMutationPayload {
  draftOrder: DraftOrder
}

type DraftOrdersMutationPayload {
  draftOrderId: ID
}


# ---------- Mutation payloads ----------

type SubscriptionMutationPayload {
  subscriptionId: ID
}

type SubscriptionLineMutationPayload {
  lineID: ID
  subscriptionId: Subscription
}

type OrderMutationPayload {
  orderId: ID
}

type BillingAttemptMutationPayload {
  billingAttemptId: ID
  orderId: ID
}

type CustomerMutationPayload {
  customerId: ID
}


########################
# Mutations
########################

type Mutation {
  # ---- Subscriptions ----
  createSubscription(input: CreateSubscriptionInput!): SubscriptionMutationPayload!
  updateSubscription(input: UpdateSubscriptionInput!): SubscriptionMutationPayload!
  skipNextOrder(subscriptionId: ID!, nextChargeDate: DateTime): SubscriptionMutationPayload!

  # ---- Subscription lines ----
  addSubscriptionLines(subscriptionId: ID!, lines: [CreateSubscriptionLineInput!]!): SubscriptionMutationPayload!
  updateSubscriptionLine(input: UpdateSubscriptionLineInput!): SubscriptionLineMutationPayload!

  """
  Swap a subscription line's product variant. This is a convenience wrapper
  around removing the old line and adding a new one, preserving quantity by default.
  If a priceOverride is provided, the server normalizes to currency precision (e.g., 2 decimals).
  """
  swapSubscriptionLine(
    lineId: ID!
    newVariantId: ID!
    keepQuantity: Boolean = true
    quantity: Int
    priceOverride: Float
  ): SubscriptionLineMutationPayload!

  removeSubscriptionLine(lineId: ID!): SubscriptionMutationPayload!

  # ---- Billing attempts ----
  createBillingAttempt(subscriptionId: ID!, idempotencyKey: String): BillingAttemptMutationPayload!

  # ---- Customers ----
  updateCustomer(input: UpdateCustomerInput!): CustomerMutationPayload!

  # ---- Payment methods ----
  setSubscriptionPaymentMethod(subscriptionId: ID!, paymentMethodId: ID!): SubscriptionMutationPayload!

  # ---- One-time add-ons ----
  addOneTimeAddOn(subscriptionId: ID!, variantId: ID!, quantity: Int! = 1): SubscriptionMutationPayload!
  updateOneTimeAddOn(oneTimeLineId: ID!, variantId: ID, quantity: Int): SubscriptionMutationPayload!
  removeOneTimeAddOn(oneTimeLineId: ID!): SubscriptionMutationPayload!

  # ---- Discount codes ----
  applyDiscountCode(subscriptionId: ID!, code: String!): SubscriptionMutationPayload!
  removeDiscountCode(subscriptionId: ID!, code: String!): SubscriptionMutationPayload!

  """
  Apply edits to a draft order (add/remove/update lines).
  This does NOT alter the underlying subscription lines.
  """
  updateDraftOrder(input: UpdateDraftOrderInput!): DraftOrderMutationPayload!
}


# -------------------------------------
# Payment Method - BEGIN
# -------------------------------------

"""Represents a stored payment instrument usable for recurring charges."""
type PaymentMethod {
  """Opaque internal identifier."""
  id: ID!

  """Creation timestamp in the current system."""
  createdAt: DateTime!

  """Last update timestamp in the current system."""
  updatedAt: DateTime!

  # --- Ownership & associations ---

  """Owning customer; all access must be scoped by merchant & auth policy."""
  customer: Customer!

  """
  Subscriptions currently linked to this payment method.
  Useful for impact analysis when a method is revoked or expires.
  """
  subscriptions: [Subscription!]!

  # --- Instrument & provider linkage ---

  """
  Instrument type determines which details object is populated (card or PayPal).
  """
  instrument: PaymentMethodInstrumentType!

  """
  External linkage to the provider/vault (e.g., Shopify Payment Method ID).
  Reuses the standard ExternalRef so all entities share the same shape.
  """
  external: ExternalRef

  """Source/vendor label for diagnostics (e.g., 'SHOPIFY', 'STRIPE')."""
  source: String

  # --- PCI-safe details (masked) ---

  """Card details when instrument=CREDIT_CARD. PCI-safe, masked."""
  card: PaymentCardDetails

  """PayPal details when instrument=PAYPAL_BILLING_AGREEMENT."""
  paypal: PaypalDetails

  """Billing address associated with this method (if provided)."""
  billingAddress: SubscriptionAddress

  # --- Lifecycle & compliance ---

  """Revocation metadata (when a method was disabled/invalidated)."""
  revocation: PaymentMethodRevocation
}

"""Supported payment instrument kinds."""
enum PaymentMethodInstrumentType {
  CREDIT_CARD
  PAYPAL_BILLING_AGREEMENT
  SHOP_PAY_AGREEMENT
}

"""Masked card details safe for display and support flows."""
type PaymentCardDetails {
  """Card brand/network (e.g., VISA, AMEX)."""
  brand: String
  """Last 4 digits of the PAN (mask only)."""
  last4: String
  """
  Expiration month as an integer (1–12).
  Leading zeros should be added only at presentation time.
  """
  expMonth: Int
  """Expiration year as a four-digit integer (e.g., 2030)."""
  expYear: Int
  """Cardholder name as captured by the provider/vault."""
  name: String
  """
  Optional masked digits for virtualized instruments (e.g., network tokens).
  """
  virtualLast4: String
}


"""PayPal-specific details safe for display."""
type PaypalDetails {
  """Email address of the PayPal billing agreement."""
  accountEmail: String
}

"""Revocation metadata used for audit and UX messaging."""
type PaymentMethodRevocation {
  """When this method was revoked/disabled."""
  revokedAt: DateTime
  """Human-readable reason for revocation (provider or internal)."""
  revokedReason: String
}

# -------------------------------------
# Payment Method - END
# -------------------------------------


# -------------------------------------
# Merchant (lean version for MVP) - BEGIN
# -------------------------------------

"""Represents a merchant/tenant that owns customers, products, and subscriptions."""
type Merchant {
  """Opaque internal identifier."""
  id: ID!

  """Creation timestamp."""
  createdAt: DateTime!

  """Last update timestamp."""
  updatedAt: DateTime!

  """Legal/organization display name."""
  name: String!

  """Shopfront name used on the portal/store."""
  shopName: String!

  """Default currency (ISO 4217, e.g., USD, BRL)."""
  currencyCode: String!

  """Primary IANA timezone for billing/scheduling (e.g., America/New_York)."""
  timezone: String!

  """
  Operational settings safe to expose (no secrets).
  Keep this minimal; add fields incrementally as UI requires.
  """
  settings: MerchantSettings!

  """
  Customers belonging to this merchant (paginated).
  Filters are optional; results are always scoped to this merchant.
  """
  customers(filter: CustomerFilter, first: Int = 20, after: String): CustomerConnection!

  """
  Subscriptions under this merchant (paginated).
  Filters are optional; results are always scoped to this merchant.
  """
  subscriptions(filter: SubscriptionFilter, first: Int = 20, after: String): SubscriptionConnection!
}

"""
Lean, non-secret settings. Avoid credentials/tokens here.
Future additions should be driven by concrete UI needs.
"""
type MerchantSettings {
  """
  Queue/shard index used to route events for this merchant.
  Exposed for observability; not security-sensitive.
  """
  eventQueueIndex: Int!

  """Enable FullStory (or similar session replay) on the portal."""
  fullStoryEnabled: Boolean

  """Whether UI should request full name instead of first/last."""
  requireFullName: Boolean

  """Whether this merchant operates under US-only rules."""
  usOnly: Boolean


  """Optional translations metadata (namespaces/keys; not full content)."""
  translations: JSON
}

# -------------------------------------
# Deliberately NOT included (for now)
# -------------------------------------
# - Feature flags: add later as a dedicated type if/when the client needs them.
# - Integrations and credentials: keep in backend vault; expose only high-level
#   connection state later (non-secret) through separate queries.
# - Email/SMS templates: postpone; when needed, expose TemplateRef via dedicated queries.

# -------------------------------------
# Merchant (lean version for MVP) - END
# -------------------------------------

# -------------------------------------
# Customer - BEGIN
# -------------------------------------

"""Customer membership status used for eligibility, perks, and prioritization."""
type CustomerMembership {
  """Coarse-grained state (e.g., ACTIVE, PAUSED, EXPIRED). Free string initially to avoid over-modeling."""
  status: String
  """Optional detail blob for UI badges or backend rules; can later be normalized."""
  details: JSON
}

"""Customer lifecycle metrics.
Intentionally merchant-only by policy to avoid confusing end-users with analytics."""
type CustomerStatistics {
  """Date when this customer was successfully won back after churn."""
  winBackDate: Date
}


"""Represents an end-user who owns subscriptions and orders under a merchant."""
type Customer {
  """Opaque internal identifier."""
  id: ID!

  """Creation timestamp in the current system."""
  createdAt: DateTime!

  """Last update timestamp in the current system."""
  updatedAt: DateTime!

  # --- Contact info (kept minimal for UX & filtering) ---

  """Given name; optional as some records may come incomplete from external systems."""
  firstName: String

  """Family name; optional for the same reason as firstName."""
  lastName: String

  """Primary email address; used for login, comms, and deduping."""
  email: String!

  """Primary phone number; optional. Used for SMS comms and delivery coordination."""
  phone: String

  # --- External linkage & metadata ---

  """
  External linkage to the source-of-truth system (e.g., Shopify).
  Reuses the standard ExternalRef so all entities share the same shape.
  Visible to both merchant and customer unless policy restricts it.
  """
  external: ExternalRef

  """
  Free-form metadata stored on the customer record.
  Keep PII out; use for non-critical UI badges or migration breadcrumbs.
  """
  metadata: JSON

  # --- Membership (for perks/eligibility/segmentation) ---

  """
  Customer membership info. Kept flexible to avoid premature over-modeling.
  """
  membership: CustomerMembership

  # --- Preferences & lifecycle ---

  """
  Whether the customer opted in to receive SMS communications.
  Drives UI toggles and campaign eligibility.
  """
  smsOptedIn: Boolean!

  """
  Lifecycle metrics for analytics (e.g., win-back moment).
  Merchant-only by policy; hide from end-users to avoid confusion.
  """
  statistics: CustomerStatistics

  # --- Ownership & relations ---

  """Owning merchant/tenant; all access must be scoped by merchant."""
  merchant: Merchant!

  """Subscriptions owned by this customer (scoped by merchant)."""
  subscriptions: [Subscription!]!

  # """Orders placed by this customer (scoped by merchant)."""
  # orders: [Order!]!

  """Stored payment methods (masked; PCI-safe fields only)."""
  paymentMethods: [PaymentMethod!]!
}

# -------------------------------------
# Customer - END
# -------------------------------------

"""Supported time units for subscription cadences."""
enum FrequencyUnit {
  DAY
  WEEK
  MONTH
  YEAR
}

"""A cadence represented by a numeric value and a time unit (e.g., 4 WEEKS)."""
type Frequency {
  value: Int!    # matches z.number().int().min(1)
  unit: FrequencyUnit!
}

"""Anchor type tells how to interpret calendar anchors."""
enum BillingAnchorType {
  """Align to a billing schedule (e.g., next charge anchor)."""
  BILLING
  """Align to fulfillment/shipping schedule."""
  FULFILLMENT
  """Align to a specific calendar rule (e.g., first business day)."""
  CALENDAR
}

"""Calendar anchor marker used to compute next charges/fulfillments."""
type BillingAnchor {
  day: Int!      # 1..31
  month: Int!    # 1..12
  year: Int      # optional; if omitted treat as recurring pattern
  type: BillingAnchorType!
}

enum SubscriptionStatus { ACTIVE PAUSED CANCELED IN_DUNNING EXPIRED }

type Subscription {
  id: ID!

  """Owning merchant and customer."""
  merchant: Merchant!
  customer: Customer!

  """Top-level status (ACTIVE, PAUSED, CANCELED, etc.)."""
  status: SubscriptionStatus!

  """Base billing cadence for this subscription (anchor period)."""
  frequency: Frequency!

  """Anchor markers that help compute scheduling."""
  anchors: [BillingAnchor!]!

  """3-letter ISO currency code (e.g., 'USD')."""
  currencyCode: String!

  """Next billing date according to the anchor calendar."""
  nextBillingDate: DateTime!

  # """Assigned pricing policy information (merchant-only)."""
  # pricingPolicy: [PricingPolicyAssignment!] # auth will restrict

  """Cancellation metadata (optional)."""
  cancellation: CancellationInfo

  """Risk and operational stats (merchant-only)."""
  statistics: SubscriptionStatistics

  """Delivery price estimation for the next cycle (optional)."""
  deliveryPrice: Float

  """Gift-specific info (optional)."""
  gift: GiftInfo

  """External linkage (e.g. Shopify)."""
  external: ExternalRef

  """Payment method masked reference."""
  paymentMethod: PaymentMethod

  """Whether the subscription was split."""
  isSplit: Boolean

  """Free-form notes visible on orders (e.g., allergies)."""
  orderNotes: String

  """Count of lines attached to this subscription."""
  lineCount: Int!

  """Lines (each line references a Variant; per-line cadence below)."""
  lines: [SubscriptionLine!]!

  """Orders generated from this subscription."""
  orders: [Order!]!

  """Discount codes applied to this subscription."""
  discounts: [Discount!]!
}

"""Cancellation metadata grouped for clarity and optionality.
Only present when a subscription was canceled.
Exposed to merchants (for analytics and reporting) and to customers
only when they themselves canceled."""
type CancellationInfo {
  """Date the subscription was canceled."""
  canceledAt: DateTime

  """Actor who triggered the cancellation (system, merchant, or customer email).
  Merchant-only field to avoid exposing internal identifiers to customers."""
  canceledBy: String

  """Structured reason codes or free-form data provided during cancellation.
  Useful for churn analysis; merchant-only."""
  reasons: JSON
}

"""Operational metrics and risk indicators.
Used internally for churn prediction, delivery success rates, etc.
Merchant-only: not exposed to customers."""
type SubscriptionStatistics {
  """Churn probability or relative risk score (0–1)."""
  churnRisk: Float
}

"""External system linkage, e.g. Shopify.
Keeps source of truth reference for reconciliation.
Visible to both merchant and customer if not sensitive."""
type ExternalRef {
  """External ID in the connected system (e.g., Shopify contract ID)."""
  id: String

  """Creation date in the external system (for audit and sync)."""
  createdAt: DateTime
}

"""Gift-related information when a subscription was purchased as a gift.
Visible to both merchant and recipient (if applicable)."""
type GiftInfo {
  """Alternate delivery address for the gift recipient."""
  address: SubscriptionAddress

  """Recipient's birthday if provided (used for reminders or promotions)."""
  birthDate: Date
}

"""Postal address model used for billing or shipping.
Simplified subset of full address fields."""
type SubscriptionAddress {
  """Contact name associated with this address."""
  name: String

  """First address line (street, number)."""
  line1: String

  """Second address line (apartment, suite, etc.)."""
  line2: String

  """City name."""
  city: String

  """Region, province, or state."""
  region: String

  """Postal or ZIP code."""
  postalCode: String

  """Two-letter ISO country code (e.g., 'US', 'BR')."""
  countryCode: String

  """Optional phone number for delivery coordination."""
  phone: String
}

"""
Aggregate metrics for subscriptions matched by a filter.
Additional fields can be added over time without breaking clients.
"""
type SubscriptionsAggregate {
  """Number of subscriptions that match the filter."""
  count: Int!
}

"""
Represents an individual line item within a subscription.
Each line is a static snapshot of a product variant at the time it was added to the subscription.
"""
type SubscriptionLine {
  """Unique identifier for this line."""
  id: ID!

  """Date when this line was created."""
  createdAt: DateTime!

  """Date when this line was last updated."""
  updatedAt: DateTime!

  """
  External references to the source e-commerce system.
  Example: Shopify line item ID or selling plan ID.
  """
  externalRefs: SubscriptionLineExternalRefs

  """
  Title of the product at the time the line was created.
  """
  title: String!

  """Title of the variant at the time the line was created."""
  variantTitle: String

  """URL of the variant image."""
  variantImage: String

  """Stock keeping unit for this product variant."""
  sku: String

  """Pricing information for this line."""
  pricing: SubscriptionLinePricing!

  """Quantity of units in this line."""
  quantity: Int!

  """Whether this item is one-time (non-recurring)."""
  isOneTime: Boolean!

  """
  Number of cycles to skip when this line is out of stock.
  Used for automatic rollover logic.
  """
  outOfStockRollover: Int!

  """Whether this line should be skipped in the next billing cycle."""
  shouldSkipItem: Boolean!

  """Identifier of the bundle this line belongs to, if any."""
  bundleId: ID

  """Custom attributes stored for this line (free-form JSON)."""
  customAttributes: JSON

  """
  Type of this line (e.g., STANDARD or ATTRIBUTE).
  """
  type: SubscriptionLineType!

  """Delivery cadence configuration and state for this line."""
  deliveryCadence: SubscriptionLineDeliveryCadence

  """Parent subscription that this line belongs to."""
  subscription: Subscription!

  """
  Linked product reference (live data, optional).
  """
  product: Product

  """
  Linked variant reference (live data, optional).
  """
  variant: ProductVariant
}

"""
External references to the source platform.
"""
type SubscriptionLineExternalRefs {
  """ID of the subscription line item on the external platform (e.g. Shopify)."""
  lineItemId: String
  """ID of the selling plan associated with this line."""
  sellingPlanId: String
}

"""
Pricing data specific to a subscription line.
"""
type SubscriptionLinePricing {
  """Current unit price of the line item."""
  currentPrice: Float!
  """Discounted price applied to this line, if any."""
  discountedPrice: Float
  """Original prepaid price, if applicable."""
  prepaidOriginalPrice: Float
}

"""
Enumeration of possible subscription line types.
"""
enum SubscriptionLineType {
  STANDARD
  ATTRIBUTE
}

"""
Configuration and runtime state for line-specific delivery cadence.
Used when this line runs on a different frequency than the subscription anchor.
"""
type SubscriptionLineDeliveryCadence {
  """
  Number of orders between deliveries for this line.
  Example: 2 means this line is delivered every 2 billing cycles.
  """
  everyXOrders: Int!

  """
  Number of remaining billing cycles until this line should be delivered again.
  Decremented automatically after each billing cycle.
  """
  remainingCycles: Int!

  """
  Indicates whether this cadence is currently active (true if this line
  should be included in the next billing cycle).
  """
  isActive: Boolean!
}


"""
Represents a processed order generated from a subscription.
Includes monetary amounts, fulfillment status, and external references.
"""
type Order {
  """Unique identifier for this order."""
  id: ID!

  """Date when this order was created."""
  createdAt: DateTime!

  """Date when this order was last updated."""
  updatedAt: DateTime!

  """External references to the source e-commerce system."""
  externalRefs: OrderExternalRefs!

  """Human-readable name or identifier for this order (e.g. #12345)."""
  name: String

  """Currency code for all monetary amounts in this order (ISO 4217)."""
  currency: String!

  """Total price of the order after discounts and taxes."""
  totalPrice: Float!

  """Total discount amount applied to the cart."""
  cartDiscountAmount: Float!

  """Total shipping cost of this order."""
  totalShippingPrice: Float!

  """Total tax applied to this order."""
  totalTax: Float!

  """Fulfillment status of this order (e.g. FULFILLED, PARTIAL, PENDING)."""
  fulfillmentStatus: String

  """Indicates whether this order was imported from an external source."""
  isImported: Boolean!

  """Additional metadata or details stored as free-form JSON."""
  additionalDetails: JSON

  """Optional note left by the customer or merchant."""
  note: String

  """Comma-separated tags associated with this order."""
  tags: String

  """Address information used for this order."""
  address: JSON

  """Presentment currency details (used for multi-currency support)."""
  presentment: OrderPresentment

  """Related merchant who owns this order."""
  merchant: Merchant!

  """Customer who placed this order."""
  customer: Customer!

  """Subscription this order belongs to, if applicable."""
  subscription: Subscription

  """Line items that compose this order."""
  lines: [OrderLine!]!
}

"""
External identifiers for the order.
"""
type OrderExternalRefs {
  """Order ID on the external platform (e.g. Shopify)."""
  orderId: String!
  """Date when this order was created externally."""
  externalCreatedAt: DateTime!
  """Date when the order was processed externally (fulfilled, billed, etc.)."""
  processedAt: DateTime
}

"""
Presentment details for multi-currency environments.
Used when the storefront currency differs from the billing currency.
"""
type OrderPresentment {
  """Total price presented to the customer."""
  totalPrice: Float
  """Discount amount presented to the customer."""
  cartDiscountAmount: Float
  """Shipping price presented to the customer."""
  totalShippingPrice: Float
  """Total tax presented to the customer."""
  totalTax: Float
  """Currency code used for presentment."""
  currency: String
}

# ------------------------------------------------------------
# ORDER LINE
# ------------------------------------------------------------

"""
Represents an individual product line within an order.
Each line corresponds to a purchased product variant.
"""
type OrderLine {
  """Unique identifier for this order line."""
  id: ID!

  """Date when this line was created."""
  createdAt: DateTime!

  """Date when this line was last updated."""
  updatedAt: DateTime!

  """External identifiers for this order line."""
  externalRefs: OrderLineExternalRefs!

  """Product and variant information captured at checkout."""
  product: Product
  variant: ProductVariant

  """Title of the product at the time of purchase."""
  title: String!

  """Variant title (e.g., 250ml, Blue, Size M)."""
  variantTitle: String

  """Variant image URL at the time of purchase."""
  variantImage: String

  """Stock keeping unit for this variant."""
  sku: String

  """Quantity purchased for this line."""
  quantity: Int!

  """Pricing information for this order line."""
  pricing: OrderLinePricing!

  """Indicates whether this item is one-time or recurring."""
  isOneTime: Boolean!
}

"""
External identifiers for an order line.
"""
type OrderLineExternalRefs {
  """External order ID (e.g. Shopify Order ID)."""
  orderId: String!
  """External order line item ID (e.g. Shopify Line Item ID)."""
  lineItemId: String!
}

"""
Pricing details for an order line.
"""
type OrderLinePricing {
  """Original unit price before discounts."""
  originalPrice: Float!
  """Discounted unit price after promotions."""
  discountedPrice: Float!
  """Presentment price data for multi-currency support."""
  presentment: OrderLinePresentment
}

"""
Presentment pricing details for a specific order line.
"""
type OrderLinePresentment {
  """Original price in presentment currency."""
  originalPrice: Float
  """Discounted price in presentment currency."""
  discountedPrice: Float
  """Currency code used for presentment."""
  currency: String
}

"""
Represents an individual attempt to bill a subscription.
Each attempt tracks its execution, result, and linkage to the generated order (if any).
"""
type BillingAttempt {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  """External references to the source e-commerce system."""
  externalRefs: BillingAttemptExternalRefs!

  """Unique idempotency key used to ensure safe retry behavior."""
  idempotencyKey: String!

  """Error details if the billing attempt failed."""
  error: BillingAttemptError

  """Date when this attempt was completed successfully."""
  completedAt: DateTime

  """Indicates whether this attempt resulted in a partial fulfillment."""
  isPartialFulfillment: Boolean

  """Origin or trigger for this billing attempt."""
  source: BillingAttemptSource

  """Subscription this billing attempt belongs to."""
  subscription: Subscription!

  """Merchant that owns this billing attempt."""
  merchant: Merchant!

  """Customer that this billing attempt was intended to charge."""
  customer: Customer

  """Order generated from this attempt, if applicable."""
  order: Order
}

"""
External identifiers for the billing attempt.
"""
type BillingAttemptExternalRefs {
  """External ID for this billing attempt (e.g. Shopify Billing Attempt ID)."""
  billingAttemptId: String!
}

"""
Encapsulates error details for a billing attempt.
"""
type BillingAttemptError {
  """Machine-readable error code."""
  code: String
  """Human-readable error message."""
  message: String
}

"""
Possible sources or triggers for a billing attempt.
"""
enum BillingAttemptSource {
  """Billing triggered manually from the 'Get It Now' flow."""
  GET_IT_NOW

  """Billing triggered automatically by the scheduled billing job."""
  BILLING_JOB
}

"""Lifecycle status of a product or variant (mirrors PRODUCT_STATUS)."""
enum ProductStatus {
  ARCHIVED
  ACTIVE
  DRAFT
  DELETED
}

"""Weight unit used by variants (mirrors WEIGHT_UNIT)."""
enum WeightUnit {
  GRAMS
  KILOGRAMS
  OUNCES
  POUNDS
}

"""Discount type for price settings (mirrors PRODUCT_DISCOUNT)."""
enum ProductDiscountType {
  PERCENTAGE
  FIXED
}

"""
Pricing configuration used to compute one-time and subscription prices.
May exist at product level or variant level. Uses Decimal to avoid rounding issues.
"""
type PriceSettings {
  """Unique identifier for these price settings."""
  id: ID!

  """Discount type to apply for subscription purchases (PERCENTAGE or FIXED)."""
  subscriptionDiscountType: ProductDiscountType!

  """Discount type to apply for one-time purchases (PERCENTAGE or FIXED)."""
  oneTimeDiscountType: ProductDiscountType!

  """
  Discount amount for subscriptions.
  - When PERCENTAGE: 0..100 (e.g., 15.5 = 15.5%)
  - When FIXED: currency amount (minor precision preserved with Decimal)
  """
  subscriptionDiscountAmount: Decimal!

  """
  Discount amount for one-time purchases.
  - When PERCENTAGE: 0..100
  - When FIXED: currency amount
  """
  oneTimeDiscountAmount: Decimal!

  """Whether the subscription discount is enabled."""
  isSubscriptionDiscountEnabled: Boolean!

  """Whether the one-time discount is enabled."""
  isOneTimeDiscountEnabled: Boolean!

  """Creation timestamp."""
  createdAt: DateTime!

  """Last update timestamp."""
  updatedAt: DateTime!
}

"""Represents a sellable product owned by a merchant."""
type Product {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  """Owning merchant (maps from accountId)."""
  merchant: Merchant!

  """External linkage to the catalog source (e.g., Shopify Product ID)."""
  external: ExternalRef!

  """Human-friendly product title."""
  title: String!

  """Lifecycle status of this product."""
  status: ProductStatus!

  """Primary image URL (optional)."""
  imageUrl: String

  """
  When true, per-variant pricing should be used; otherwise product-level settings apply.
  Mirrors 'useProductVariantPricing'.
  """
  useVariantPricing: Boolean!

  """Pricing configuration at product level (optional)."""
  priceSettings: PriceSettings

  """Display/merchandising knobs grouped to avoid polluting the root."""
  merchandising: ProductMerchandising!

  """Whether this product is a bundle parent."""
  isBundleParent: Boolean!

  """Variants belonging to this product (Relay-style connection)."""
  variants(first: Int = 20, after: String): VariantConnection!
}

"""UI/merchandising settings for product presentation."""
type ProductMerchandising {
  """Carousel slot index for home/catalog placement."""
  carouselPosition: Int!
  """General sort rank (server enforces 0..30)."""
  sortPosition: Int!
  """Whether this product is visible in the catalog."""
  isInCatalog: Boolean!
}

"""Represents a specific purchasable configuration of a product."""
type ProductVariant {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  """Owning merchant (maps from accountId)."""
  merchant: Merchant!

  """Owning product."""
  product: Product!

  """External linkage to the catalog source (e.g., Shopify Variant ID)."""
  external: ExternalRef!

  """Human-friendly variant title (e.g., 250ml, Blue, Size M)."""
  title: String!

  """Lifecycle status of this variant."""
  status: ProductStatus!

  """Primary image URL (optional)."""
  imageUrl: String

  """
  Base unit price for this variant.
  Use Decimal to preserve monetary precision.
  """
  price: Decimal!

  """Whether this variant is currently out of stock."""
  isOutOfStock: Boolean!

  """Enable subscription purchase in the Customer Portal."""
  enableSubscriptionInCP: Boolean!

  """Enable one-time purchase in the Customer Portal."""
  enableOneTimeInCP: Boolean!

  """Pricing configuration at variant level (optional)."""
  priceSettings: PriceSettings

  """Weight unit used for shipping and logistics."""
  weightUnit: WeightUnit!

  """Weight numeric value."""
  weightValue: Float!

  """Whether this variant requires shipping (vs digital/service)."""
  requiresShipping: Boolean!

  """Optional legacy identifier kept for migration/audit."""
  legacyId: String

  """Stock keeping unit identifier."""
  sku: String

  """Display position among the product's variants."""
  position: Int!
}

"""
Represents a discount applied to a subscription.
Only the code is guaranteed at this time; other fields are optional
and allow future expansion without breaking clients.
"""
type Discount {
  """The discount code (e.g., SPRING10)."""
  code: String!
}

# ----------------------------
# Draft Orders - Types (no status)
# ----------------------------

"""
Server-side preview of upcoming orders for a subscription.
Each DraftOrder represents one future billing/delivery cycle.
It can be edited (add/remove/update lines) before the billing job runs.
"""
type DraftOrder {
  id: ID!
  subscriptionId: ID!
  """0-based index relative to the next billing cycle (0=next, 1=second next, ...)."""
  cycleIndex: Int!
  """Projected billing date for this cycle (anchor-based), before edits."""
  billingDate: DateTime!
  """Projected delivery date for this cycle, if different from billing."""
  deliveryDate: DateTime
  """Lines composing this draft, after applying cadence rules and current edits."""
  lines: [DraftOrderLine!]!
  """Projected total price for this draft (best-effort; may differ at runtime)."""
  projectedTotalPrice: Float
  """Last time this draft was updated (edits applied)."""
  updatedAt: DateTime!
  """Optional human-readable notes (e.g., holiday shifts, manual adjustments)."""
  notes: String
}

"""
A line inside a DraftOrder. It may originate from a subscription line
(or be a one-time ad-hoc addition).
"""
type DraftOrderLine {
  id: ID!
  """If this line comes from a subscription line, this references it."""
  subscriptionLineId: ID
  """When present, the live variant reference (safe for UI linking)."""
  variant: ProductVariant
  """Snapshot fields used for display even if variant is missing."""
  title: String!
  variantTitle: String
  variantImage: String
  sku: String
  quantity: Int!
  """Per-line pricing in the draft context (after discounts/overrides)."""
  pricing: DraftOrderLinePricing!
  """Reason when willShip=false or overridden (e.g., 'EVERY_3_ORDERS', 'SKIPPED', etc.)."""
  reason: String
  """True if this line was added ad-hoc in the draft (not persistent on the subscription)."""
  isOneTime: Boolean!
}

type DraftOrderLinePricing {
  originalUnitPrice: Float!
  discountedUnitPrice: Float!
}